<?php

namespace MehrIt\AmazonSellingPartner\Api\UpdateInventoryApi;

use MehrIt\AmazonSellingPartner\AccessToken;
use MehrIt\AmazonSellingPartner\Configuration;
use MehrIt\AmazonSellingPartner\Exception\ApiException;
use MehrIt\AmazonSellingPartner\Exception\InvalidArgumentException;
use MehrIt\AmazonSellingPartner\HttpFactory;
use MehrIt\AmazonSellingPartner\HttpSignatureHeaders;
use MehrIt\AmazonSellingPartner\ObjectSerializer;
use Psr\Http\Client\ClientExceptionInterface;
use Psr\Http\Client\ClientInterface;
use Psr\Http\Message\RequestInterface;
use Psr\Log\LoggerInterface;

/**
 * This class was auto-generated by https://github.com/OpenAPITools/openapi-generator/.
 * Do not change it, it will be overwritten with next execution of /bin/generate.sh
 */
final class ExternalFulfillmentInventorySDK
{
    public const API_NAME = 'ExternalFulfillmentInventory';

    public const OPERATION_UPDATEINVENTORY = 'updateInventory';

    public const OPERATION_UPDATEINVENTORY_PATH = '/externalFulfillment/inventory/2021-01-06/locations/{locationId}/skus/{skuId}';

    private ClientInterface $client;

    private HttpFactory $httpFactory;

    private Configuration $configuration;

    private LoggerInterface $logger;

    public function __construct(ClientInterface $client, HttpFactory $requestFactory, Configuration $configuration, LoggerInterface $logger)
    {
        $this->client = $client;
        $this->httpFactory = $requestFactory;
        $this->configuration = $configuration;
        $this->logger = $logger;
    }

    /**
     * Operation updateInventory
     *
     * @param AccessToken $accessToken
     * @param string $region
     * @param string $location_id The node identifier for the seller&#39;s location in smart connect for which inventory is being updated (required)
     * @param string $sku_id The listing identifier for which inventory is being updated (required)
     * @param int $quantity The absolute number of items of the specified SKU available at the specified node. This value should always be a non-zero positive integer (required)
     * @param string $if_match A unique number provided with each call to update the inventory. This number must be latest version of entity that exist in system. It will be equal to comparison against existing version of entity. (optional)
     * @param string $if_unmodified_since Timestamp or increasing number which does greater than comparison before applying the change. This is different than version of entity and used to overwrite the latest data. It should follow data/time format of rfc2616, e.g: Sun, 06 Nov 1994 08:49:37 GMT (optional)
     *
     * @throws \MehrIt\AmazonSellingPartner\Exception\ApiException on non-2xx response
     * @throws \MehrIt\AmazonSellingPartner\Exception\InvalidArgumentException
     * @return \MehrIt\AmazonSellingPartner\Model\ExternalFulfillmentInventory\InventorySnapshot
     */
    public function updateInventory(AccessToken $accessToken, string $region, $location_id, $sku_id, $quantity, $if_match = null, $if_unmodified_since = null)
    {
        $request = $this->updateInventoryRequest($accessToken, $region, $location_id, $sku_id, $quantity, $if_match, $if_unmodified_since);

        $this->configuration->extensions()->preRequest('ExternalFulfillmentInventory', 'updateInventory', $request);

        try {
            $correlationId = \uuid_create(UUID_TYPE_RANDOM);

            if ($this->configuration->loggingEnabled('ExternalFulfillmentInventory', 'updateInventory')) {

                $sanitizedRequest = $request;

                foreach ($this->configuration->loggingSkipHeaders() as $sensitiveHeader) {
                    $sanitizedRequest = $sanitizedRequest->withoutHeader($sensitiveHeader);
                }

                $this->logger->log(
                    $this->configuration->logLevel('ExternalFulfillmentInventory', 'updateInventory'),
                    'Amazon Selling Partner API pre request',
                    [
                        'api' => 'ExternalFulfillmentInventory',
                        'operation' => 'updateInventory',
                        'request_correlation_id' => $correlationId,
                        'request_body' => (string) $sanitizedRequest->getBody(),
                        'request_headers' => $sanitizedRequest->getHeaders(),
                        'request_uri' => (string) $sanitizedRequest->getUri(),
                    ]
                );
            }

            $response = $this->client->sendRequest($request);

            $this->configuration->extensions()->postRequest('ExternalFulfillmentInventory', 'updateInventory', $request, $response);

            if ($this->configuration->loggingEnabled('ExternalFulfillmentInventory', 'updateInventory')) {

                $sanitizedResponse = $response;

                foreach ($this->configuration->loggingSkipHeaders() as $sensitiveHeader) {
                    $sanitizedResponse = $sanitizedResponse->withoutHeader($sensitiveHeader);
                }

                $this->logger->log(
                    $this->configuration->logLevel('ExternalFulfillmentInventory', 'updateInventory'),
                    'Amazon Selling Partner API post request',
                    [
                        'api' => 'ExternalFulfillmentInventory',
                        'operation' => 'updateInventory',
                        'response_correlation_id' => $correlationId,
                        'response_body' => (string) $sanitizedResponse->getBody(),
                        'response_headers' => $sanitizedResponse->getHeaders(),
                        'response_status_code' => $sanitizedResponse->getStatusCode(),
                    ]
                );
            }
        } catch (ClientExceptionInterface $e) {
            throw new ApiException(
                "[{$e->getCode()}] {$e->getMessage()}",
                (int) $e->getCode(),
                null,
                null,
                $e
            );
        }

        $statusCode = $response->getStatusCode();

        if ($statusCode < 200 || $statusCode > 299) {
            throw new ApiException(
                sprintf(
                    '[%d] Error connecting to the API (%s)',
                    $statusCode,
                    (string) $request->getUri()
                ),
                $statusCode,
                $response->getHeaders(),
                (string) $response->getBody()
            );
        }

        return ObjectSerializer::deserialize(
            $this->configuration,
            (string) $response->getBody(),
            '\MehrIt\AmazonSellingPartner\Model\ExternalFulfillmentInventory\InventorySnapshot',
            []
        );
    }

    /**
     * Create request for operation 'updateInventory'
     *
     * @param AccessToken $accessToken
     * @param string $region
     * @param string $location_id The node identifier for the seller&#39;s location in smart connect for which inventory is being updated (required)
     * @param string $sku_id The listing identifier for which inventory is being updated (required)
     * @param int $quantity The absolute number of items of the specified SKU available at the specified node. This value should always be a non-zero positive integer (required)
     * @param string $if_match A unique number provided with each call to update the inventory. This number must be latest version of entity that exist in system. It will be equal to comparison against existing version of entity. (optional)
     * @param string $if_unmodified_since Timestamp or increasing number which does greater than comparison before applying the change. This is different than version of entity and used to overwrite the latest data. It should follow data/time format of rfc2616, e.g: Sun, 06 Nov 1994 08:49:37 GMT (optional)
     *
     * @throws \MehrIt\AmazonSellingPartner\Exception\InvalidArgumentException
     * @return RequestInterface
     */
    public function updateInventoryRequest(AccessToken $accessToken, string $region, $location_id, $sku_id, $quantity, $if_match = null, $if_unmodified_since = null) : RequestInterface
    {
        // verify the required parameter 'location_id' is set
        if ($location_id === null || (is_array($location_id) && count($location_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $location_id when calling updateInventory'
            );
        }
        // verify the required parameter 'sku_id' is set
        if ($sku_id === null || (is_array($sku_id) && count($sku_id) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $sku_id when calling updateInventory'
            );
        }
        // verify the required parameter 'quantity' is set
        if ($quantity === null || (is_array($quantity) && count($quantity) === 0)) {
            throw new InvalidArgumentException(
                'Missing the required parameter $quantity when calling updateInventory'
            );
        }
        if ($quantity < 0) {
            throw new InvalidArgumentException('invalid value for "$quantity" when calling UpdateInventoryApi.updateInventory, must be bigger than or equal to 0.');
        }


        $resourcePath = '/externalFulfillment/inventory/2021-01-06/locations/{locationId}/skus/{skuId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $multipart = false;
        $query = '';

        // query params
        if ($quantity instanceof \DateTimeInterface) {
            $quantity = ObjectSerializer::toString($quantity);
        }
        if (is_array($quantity)) {
            $quantity = ObjectSerializer::serializeCollection($quantity, '', true);
        }
        if ($quantity !== null) {
            $queryParams['quantity'] = $quantity;
        }

        if (\count($queryParams)) {
            $query = http_build_query($queryParams);
        }

        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }
        // header params
        if ($if_unmodified_since !== null) {
            $headerParams['If-Unmodified-Since'] = ObjectSerializer::toHeaderValue($if_unmodified_since);
        }

        // path params
        if ($location_id !== null) {
            $resourcePath = str_replace(
                '{' . 'locationId' . '}',
                ObjectSerializer::toPathValue($location_id),
                $resourcePath
            );
        }
        // path params
        if ($sku_id !== null) {
            $resourcePath = str_replace(
                '{' . 'skuId' . '}',
                ObjectSerializer::toPathValue($sku_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = [
                'accept' => ['application/json'],
                'host' => [$this->configuration->apiHost($region)],
                'user-agent' => [$this->configuration->userAgent()],
            ];
        } else {
            $headers = [
                'content-type' => ['application/json'],
                'accept' => ['application/json'],
                'host' => [$this->configuration->apiHost($region)],
                'user-agent' => [$this->configuration->userAgent()],
            ];
        }

        $request = $this->httpFactory->createRequest(
            'PUT',
            $this->configuration->apiURL($region) . $resourcePath . '?' . $query
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                $request = $request->withParsedBody($multipartContents);
            } elseif ($headers['content-type'] === ['application/json']) {
                $request = $request->withBody($this->httpFactory->createStreamFromString(\json_encode($formParams)));
            } else {
                $request = $request->withParsedBody($formParams);
            }
        }

        foreach (\array_merge($headerParams, $headers) as $name => $header) {
            $request = $request->withHeader($name, $header);
        }

        return HttpSignatureHeaders::forConfig(
            $this->configuration,
            $accessToken,
            $region,
            $request
        );
    }

}
